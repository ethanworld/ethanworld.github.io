(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{432:function(t,a,e){"use strict";e.r(a);var s=e(62),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"gcc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gcc"}},[t._v("#")]),t._v(" GCC")]),t._v(" "),e("h2",{attrs:{id:"gcc概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gcc概述"}},[t._v("#")]),t._v(" GCC概述")]),t._v(" "),e("p",[t._v("GCC，GNU计划提供的编译器。")]),t._v(" "),e("p",[t._v("由源文件到可执行文件需要经历的步骤：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("预处理：头文件展开（#include）、宏替换（#define）、条件编译（#ifdef），生成"),e("code",[t._v(".i")]),t._v("文件")]),t._v(" "),e("p",[t._v("（预处理阶段处理的都是以#开头的代码）")]),t._v(" "),e("p",[e("code",[t._v("gcc -E hello.c -o hello.i")])])]),t._v(" "),e("li",[e("p",[t._v("编译：检查语法、转成汇编、生成汇编文件（.s/.S）")]),t._v(" "),e("p",[e("code",[t._v("gcc -S hello.i -o hello.s")])])]),t._v(" "),e("li",[e("p",[t._v("汇编：编译汇编文件，生成目标文件（.o）即不可执行的机器码文件")]),t._v(" "),e("p",[e("code",[t._v("gcc -c hello.s -o hello.o")])])]),t._v(" "),e("li",[e("p",[t._v("链接：链接所有目标文件，生成符号表，生成可执行文件（elf）;将不可执行的机器码文件转成可执行的文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址（得到可执行文件）")]),t._v(" "),e("p",[t._v("（elf即可执行连接文件格式，elf文件参与程序的连接和执行，即参与建立一个程序和执行一个程序的过程）")]),t._v(" "),e("p",[e("code",[t._v("gcc hello.o -o hello")])])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ethanworld/images@main/202205120802165.png",alt:"编译流程"}})]),t._v(" "),e("blockquote",[e("p",[t._v("我们也可以直接使用"),e("code",[t._v("gcc hello.c -o hello")]),t._v("一步生成binary文件hello")])]),t._v(" "),e("h2",{attrs:{id:"预处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预处理"}},[t._v("#")]),t._v(" 预处理")]),t._v(" "),e("h2",{attrs:{id:"编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[t._v("#")]),t._v(" 编译")]),t._v(" "),e("h2",{attrs:{id:"汇编"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#汇编"}},[t._v("#")]),t._v(" 汇编")]),t._v(" "),e("h2",{attrs:{id:"链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[t._v("#")]),t._v(" 链接")]),t._v(" "),e("p",[t._v("链接可分为动态链接和静态链接。")]),t._v(" "),e("p",[t._v("静态连接库：把文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件。程序体积会变大。若静态库有更新的话，所有可执行文件都得重新链接才能用上新的静态库。")]),t._v(" "),e("p",[t._v("动态链接：把调用的函数所在文件模块和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码。多个程序可以共享同一段代码。由于是运行时加载，可能会影响程序的前期执行性能。")]),t._v(" "),e("p",[t._v("动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序小巧，但是必须依赖动态库，否则无法执行。\nLinux 下的动态链接库实际是共享目标文件（shared object），一般是.so 文件，作用类似于 Windows 下的.dll 文件。\n静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过体积较大。\nLinux 下静态库是汇编产生的.o 文件的集合，一般以.a 文件形式出现。\ngcc 默认是动态链接，加上-static 参数则采用静态链接。 gcc编译系统主要由三部分组成：与语言相关的前端、与语言无关的后端、与机器相关的机器描述。")]),t._v(" "),e("h3",{attrs:{id:"动态链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态链接"}},[t._v("#")]),t._v(" 动态链接")]),t._v(" "),e("h3",{attrs:{id:"静态链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态链接"}},[t._v("#")]),t._v(" 静态链接")]),t._v(" "),e("h2",{attrs:{id:"编译选项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译选项"}},[t._v("#")]),t._v(" 编译选项")])])}),[],!1,null,null,null);a.default=v.exports}}]);